"""
Robust transcript fetching engine with multiple data sources and intelligent fallback strategies.

This module provides a centralized, robust approach to fetching YouTube transcripts with:
- Multiple data source strategies (YouTube API, Whisper, etc.)
- Intelligent language detection and prioritization
- Comprehensive error handling and classification
- Circuit breaker pattern for failing services
- Exponential backoff retry mechanisms
- Performance monitoring and metrics
"""

import asyncio
import time
import random
import ssl
import urllib3
import os
from typing import Optional, List, Dict, Any, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum
from contextlib import asynccontextmanager
from pathlib import Path
import tempfile
import re

import requests
from requests.adapters import HTTPAdapter
from urllib3.util import Retry
from youtube_transcript_api import YouTubeTranscriptApi
from youtube_transcript_api import (
    TranscriptsDisabled,
    NoTranscriptFound,
    CouldNotRetrieveTranscript,
    VideoUnavailable,
)
# Handle version differences where NoTranscriptAvailable may not be exported
try:
    from youtube_transcript_api import NoTranscriptAvailable  # type: ignore
except Exception:
    try:
        from youtube_transcript_api._errors import NoTranscriptAvailable  # type: ignore
    except Exception:  # pragma: no cover - fallback for very old/new versions
        class NoTranscriptAvailable(Exception):
            pass
try:
    from youtube_transcript_api import TooManyRequests  # Newer versions
except Exception:  # pragma: no cover - backwards compatibility
    class TooManyRequests(Exception):
        pass
from youtube_transcript_api.formatters import TextFormatter

from ..transcription import WhisperTranscriber, TranscriptUnavailable
from ..models import TranscriptSegment, VideoData, VideoInfo
from ..utils.logging import get_logger
from .cache_manager import CacheManager
from ..utils.ssl_config import get_ssl_config
import yt_dlp
import pysubs2

logger = get_logger("transcript_fetcher")


def _clean_autogenerated_transcript(raw_text: str) -> str:
    """
    Clean auto-generated transcripts by removing stuttering and repeated phrases.

    Only used for auto-generated captions. Manual and Whisper-based transcripts
    should not be cleaned with this logic.
    """
    # 1) Remove tag-like timestamps/markers and normalize whitespace
    no_timestamps = re.sub(r"<[^>]+>", "", raw_text)
    one_line_text = re.sub(r"\s+", " ", no_timestamps.replace("\\N", " ").replace("\n", " ")).strip()

    # 2) Tokenize
    words = one_line_text.split()

    # 3) Deduplicate consecutive repeated phrases
    deduped_words: List[str] = []
    i = 0
    while i < len(words):
        best_len = 0
        max_search_len = min(len(words) - i, 50)
        for length in range(int(max_search_len / 2), 0, -1):
            phrase = words[i : i + length]
            next_phrase = words[i + length : i + 2 * length]
            if phrase == next_phrase:
                best_len = length
                break

        if best_len > 0:
            current_phrase = words[i : i + best_len]
            deduped_words.extend(current_phrase)
            next_pos = i + best_len
            while (
                next_pos + best_len <= len(words)
                and words[next_pos : next_pos + best_len] == current_phrase
            ):
                next_pos += best_len
            i = next_pos
        else:
            deduped_words.append(words[i])
            i += 1

    # 4) Reassemble and minor punctuation spacing cleanup
    final_text = " ".join(deduped_words)
    final_text = final_text.replace(">>", "\n\n>>")
    final_text = re.sub(r"\s+([,.?])", r"\1", final_text)
    return final_text


class TranscriptSource(Enum):
    """Available transcript sources."""
    YOUTUBE_API = "youtube_api"
    WHISPER_OPENAI = "whisper_openai"
    WHISPER_GROQ = "whisper_groq"
    MANUAL_CAPTIONS = "manual_captions"
    AUTO_GENERATED = "auto_generated"


class TranscriptError(Exception):
    """Base class for transcript-related errors."""
    pass


class TranscriptUnavailableError(TranscriptError):
    """Transcript is not available for this video."""
    pass


class TranscriptTemporaryError(TranscriptError):
    """Temporary error that might resolve with retry."""
    pass


class TranscriptRateLimitError(TranscriptError):
    """Rate limit exceeded."""
    pass


@dataclass
class TranscriptResult:
    """Result of transcript fetching operation."""
    success: bool
    transcript: Optional[str] = None
    segments: Optional[List[Dict[str, Any]]] = None
    source: Optional[TranscriptSource] = None
    language: Optional[str] = None
    error: Optional[str] = None
    attempt_count: int = 0
    fetch_time_ms: int = 0


@dataclass
class CircuitBreakerState:
    """Circuit breaker state for a specific source."""
    failures: int = 0
    last_failure_time: float = 0
    state: str = "closed"  # closed, open, half_open
    failure_threshold: int = 5
    recovery_timeout: int = 300  # 5 minutes


@dataclass
class LanguagePreference:
    """Language preference configuration."""
    primary_languages: List[str] = field(default_factory=lambda: ['en'])
    secondary_languages: List[str] = field(default_factory=lambda: ['de', 'es', 'fr', 'it', 'pt', 'ru', 'ja', 'ko', 'zh', 'hi', 'ar'])
    auto_detect_enabled: bool = True
    prefer_manual_captions: bool = True


class RobustTranscriptFetcher:
    """
    Robust transcript fetching engine with multiple strategies and intelligent fallbacks.
    """
    
    def __init__(
        self,
        cache_manager: Optional[CacheManager] = None,
        language_preferences: Optional[LanguagePreference] = None,
        max_retries: int = 3,
        base_retry_delay: float = 1.0,
        max_retry_delay: float = 30.0,
        enable_circuit_breaker: bool = True
    ):
        self.cache = cache_manager or CacheManager()
        self.language_prefs = language_preferences or LanguagePreference()
        self.max_retries = max_retries
        self.base_retry_delay = base_retry_delay
        self.max_retry_delay = max_retry_delay
        self.enable_circuit_breaker = enable_circuit_breaker
        
        # Configure SSL settings
        self.ssl_config = get_ssl_config()
        # Prepare HTTP session for libraries that allow injection (e.g., youtube_transcript_api>=1.0)
        self._http_session = requests.Session()
        self.ssl_config.configure_requests_session(self._http_session)
        
        # Configure proxy settings if available
        self._configure_proxy_settings()
        # Add browser-like headers to avoid empty/blocked responses in some environments (e.g., Railway)
        self._http_session.headers.update({
            "User-Agent": os.getenv(
                "YOUTUBE_HTTP_USER_AGENT",
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
            ),
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": os.getenv(
                "YOUTUBE_HTTP_ACCEPT_LANGUAGE",
                "en-US,en;q=0.9,ta;q=0.6"
            ),
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
        })
        # Mount retry adapter for transient errors like 429/5xx
        retry_config = Retry(
            total=3,
            connect=3,
            read=3,
            backoff_factor=0.6,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods={"GET", "HEAD"},
            raise_on_status=False,
        )
        adapter = HTTPAdapter(max_retries=retry_config)
        self._http_session.mount("https://", adapter)
        self._http_session.mount("http://", adapter)
        
        # Circuit breaker states for each source
        self.circuit_breakers: Dict[TranscriptSource, CircuitBreakerState] = {
            source: CircuitBreakerState() for source in TranscriptSource
        }
        
        # Whisper transcribers for different providers
        self._whisper_openai = None
        self._whisper_groq = None
        
        # Performance metrics
        self.metrics = {
            'total_requests': 0,
            'success_rate': 0.0,
            'avg_response_time': 0.0,
            'source_success_rates': {source: 0.0 for source in TranscriptSource}
        }
        
        logger.info("Initialized RobustTranscriptFetcher")
    
    def _configure_proxy_settings(self):
        """Configure proxy settings for YouTube requests if available."""
        try:
            # Check for proxy configuration via environment variables
            http_proxy = os.getenv("YOUTUBE_PROXY_HTTP")
            https_proxy = os.getenv("YOUTUBE_PROXY_HTTPS")
            
            if http_proxy or https_proxy:
                proxies = {}
                if http_proxy:
                    proxies["http"] = http_proxy
                if https_proxy:
                    proxies["https"] = https_proxy
                
                self._http_session.proxies.update(proxies)
                logger.info(f"Configured HTTP proxies for YouTube requests: {list(proxies.keys())}")
                
            # Check for Webshare proxy configuration (if youtube-transcript-api supports it)
            webshare_user = os.getenv("WEBSHARE_PROXY_USERNAME")
            webshare_pass = os.getenv("WEBSHARE_PROXY_PASSWORD")
            
            if webshare_user and webshare_pass:
                # Store for later use with YouTubeTranscriptApi proxy_config
                self._webshare_config = {
                    "username": webshare_user,
                    "password": webshare_pass
                }
                logger.info("Webshare proxy credentials configured")
            else:
                self._webshare_config = None
                
        except Exception as e:
            logger.warning(f"Failed to configure proxy settings: {e}")
            self._webshare_config = None

    def _get_ytt_api(self) -> Any:
        """Return a configured YouTubeTranscriptApi instance when supported."""
        try:
            # Try to configure with proxy if Webshare credentials are available
            if hasattr(self, '_webshare_config') and self._webshare_config:
                try:
                    from youtube_transcript_api.proxies import WebshareProxyConfig
                    proxy_config = WebshareProxyConfig(
                        proxy_username=self._webshare_config["username"],
                        proxy_password=self._webshare_config["password"]
                    )
                    return YouTubeTranscriptApi(proxy_config=proxy_config)  # type: ignore[call-arg]
                except ImportError:
                    logger.debug("Webshare proxy not available, falling back to HTTP session")
                except Exception as e:
                    logger.warning(f"Failed to configure Webshare proxy: {e}")
            
            # Newer API supports passing an HTTP session
            return YouTubeTranscriptApi(http_client=self._http_session)  # type: ignore[call-arg]
        except TypeError:
            # Older versions don't accept constructor args, return class for static usage
            return YouTubeTranscriptApi

    @staticmethod
    def _normalize_transcript_entries(entries: Any) -> List[Dict[str, Any]]:
        """Normalize various transcript return types to a list of dicts.

        Handles:
        - List[dict]
        - FetchedTranscript with .to_raw_data()
        - Iterable of snippet objects with .text/.start/.duration
        """
        # FetchedTranscript with to_raw_data
        try:
            to_raw = getattr(entries, 'to_raw_data', None)
            if callable(to_raw):
                return list(to_raw())
        except Exception:
            pass

        # Already a list of dicts
        if isinstance(entries, list) and (not entries or isinstance(entries[0], dict)):
            return entries

        # Iterable of objects
        normalized: List[Dict[str, Any]] = []
        try:
            for item in entries:
                try:
                    if isinstance(item, dict):
                        text = item.get('text', '').strip()
                        start = float(item.get('start', 0))
                        duration = float(item.get('duration', 0)) if 'duration' in item else 0.0
                    else:
                        text = str(getattr(item, 'text', '')).strip()
                        start = float(getattr(item, 'start', 0) or 0)
                        duration = float(getattr(item, 'duration', 0) or 0)
                    if text:
                        normalized.append({'text': text, 'start': start, 'duration': duration})
                except Exception:
                    continue
        except Exception:
            normalized = []
        return normalized
    
    @property
    def whisper_openai(self) -> WhisperTranscriber:
        """Lazy initialization of OpenAI Whisper transcriber."""
        if self._whisper_openai is None:
            self._whisper_openai = WhisperTranscriber(provider="openai")
        return self._whisper_openai
    
    @property
    def whisper_groq(self) -> WhisperTranscriber:
        """Lazy initialization of Groq Whisper transcriber."""
        if self._whisper_groq is None:
            self._whisper_groq = WhisperTranscriber(provider="groq")
        return self._whisper_groq
    
    async def fetch_transcript(
        self,
        video_id: str,
        youtube_url: str,
        use_cache: bool = True,
        preferred_language: Optional[str] = None,
        fallback_to_whisper: bool = True
    ) -> TranscriptResult:
        """
        Fetch transcript using robust multi-strategy approach.
        
        Args:
            video_id: YouTube video ID
            youtube_url: Full YouTube URL
            use_cache: Whether to use cached results
            preferred_language: Preferred language code (overrides config)
            fallback_to_whisper: Whether to use Whisper as fallback
            
        Returns:
            TranscriptResult with success status and data
        """
        start_time = time.time()
        self.metrics['total_requests'] += 1
        
        # Check cache first
        if use_cache:
            cached_result = await self._get_cached_transcript(video_id)
            if cached_result:
                logger.debug(f"Using cached transcript for {video_id}")
                return cached_result
        
        # Determine language strategy
        languages_to_try = self._build_language_strategy(preferred_language)
        
        # Define fetching strategies in order of preference
        # 1) Try manual subtitles via yt-dlp
        # 2) Try auto-generated subtitles via yt-dlp (preferred languages, then any)
        # 3) Fallback to Whisper transcription (order optimized by video duration)
        strategies = [
            (TranscriptSource.MANUAL_CAPTIONS, self._fetch_manual_captions_ytdlp),
            (TranscriptSource.AUTO_GENERATED, self._fetch_auto_captions_ytdlp),
        ]
        
        if fallback_to_whisper:
            # Optimize whisper provider order based on video duration and available API keys
            video_duration = 0
            try:
                info = self._ytdlp_probe_info(youtube_url)
                video_duration = int(info.get('duration') or 0)
            except Exception:
                video_duration = 0
            groq_key = os.environ.get("GROQ_API_KEY")
            if video_duration and video_duration >= 45 * 60 and groq_key:
                # Prefer Groq first for long videos (often faster)
                strategies.extend([
                    (TranscriptSource.WHISPER_GROQ, self._fetch_whisper_transcript_groq),
                    (TranscriptSource.WHISPER_OPENAI, self._fetch_whisper_transcript_openai),
                ])
            else:
                strategies.extend([
                    (TranscriptSource.WHISPER_OPENAI, self._fetch_whisper_transcript_openai),
                    (TranscriptSource.WHISPER_GROQ, self._fetch_whisper_transcript_groq),
                ])
        
        # Try each strategy
        last_error = None
        for source, fetch_func in strategies:
            if not self._is_source_available(source):
                logger.debug(f"Skipping {source.value} due to circuit breaker")
                continue
            
            try:
                result = await self._execute_with_retry(
                    fetch_func, video_id, youtube_url, languages_to_try, source
                )
                
                if result.success:
                    # Update metrics and cache result
                    fetch_time_ms = int((time.time() - start_time) * 1000)
                    result.fetch_time_ms = fetch_time_ms
                    
                    self._update_success_metrics(source, fetch_time_ms)
                    
                    if use_cache:
                        await self._cache_transcript_result(video_id, result)
                    
                    logger.info(f"Successfully fetched transcript for {video_id} using {source.value}")
                    return result
                else:
                    last_error = result.error
                    self._record_failure(source)
                    
            except Exception as e:
                last_error = str(e)
                self._record_failure(source)
                logger.warning(f"Strategy {source.value} failed for {video_id}: {e}")
        
        # All strategies failed
        self._update_failure_metrics()
        return TranscriptResult(
            success=False,
            error=f"All transcript sources failed. Last error: {last_error}",
            fetch_time_ms=int((time.time() - start_time) * 1000)
        )
    
    # ---------- yt-dlp based subtitle helpers ----------
    def _ytdlp_base_opts(self) -> Dict[str, Any]:
        return {
            "quiet": True,
            "no_warnings": True,
            "noplaylist": True,
            "retries": 10,
            "socket_timeout": 20,
            "sleep_requests": 1,
            "max_sleep_requests": 3,
        }

    def _ytdlp_probe_info(self, url: str) -> Dict[str, Any]:
        # Try a clean probe first; if certain app restriction errors appear, retry with forced web client UA
        opts = self._ytdlp_base_opts()
        try:
            with yt_dlp.YoutubeDL(opts) as ydl:
                return ydl.extract_info(url, download=False) or {}
        except Exception as e:
            msg = str(e)
            if "not available on this app" in msg.lower() or "requested format is not available" in msg.lower():
                try:
                    fallback_opts = self._ytdlp_base_opts() | {
                        "http_headers": {
                            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
                        },
                        "extractor_args": {"youtube": {"player_client": ["web"]}},
                    }
                    with yt_dlp.YoutubeDL(fallback_opts) as ydl:
                        return ydl.extract_info(url, download=False) or {}
                except Exception as e2:
                    raise TranscriptTemporaryError(f"yt-dlp probe failed: {e2}")
            raise TranscriptTemporaryError(f"yt-dlp probe failed: {e}")

    def _pick_english_auto_keys(self, auto_dict: Dict[str, Any]) -> List[str]:
        keys = list(auto_dict.keys()) if auto_dict else []
        priority = ["en", "en-US", "en-GB", "en-IN", "en-CA", "en-AU"]
        picked = [k for k in priority if k in keys]
        if not picked:
            picked = [k for k in keys if k.lower() == "en" or k.lower().startswith("en-")]
        return picked[:2]

    def _list_subtitle_files(self, directory: Path) -> List[Path]:
        return sorted(list(directory.glob("*.srt")) + list(directory.glob("*.vtt")))

    def _parse_subtitle_file(self, path: Path) -> List[Dict[str, Any]]:
        try:
            subs = pysubs2.load(str(path))
        except Exception as e:
            raise TranscriptTemporaryError(f"Failed to parse subtitle file {path.name}: {e}")
        segments: List[Dict[str, Any]] = []
        for ev in subs:
            try:
                start = max(0.0, float(ev.start) / 1000.0)
                end = max(start, float(ev.end) / 1000.0)
                duration = max(0.0, end - start)
                text = (ev.text or "").replace("\n", " ").replace("\r", " ").strip()
                if text:
                    segments.append({"text": text, "start": start, "duration": duration})
            except Exception:
                continue
        # Ensure monotonic ordering
        segments.sort(key=lambda s: s["start"])
        return segments

    def _infer_lang_from_filename(self, video_id: str, file_path: Path) -> Optional[str]:
        # Expected patterns: <id>.<lang>.srt or <id>.<lang>.vtt
        stem_parts = file_path.name.split(".")
        # Examples: [<id>, <lang>, srt]
        if len(stem_parts) >= 3 and stem_parts[0] == video_id:
            return stem_parts[-2]
        return None

    async def _download_captions(self, *, url: str, langs: List[str], include_auto: bool, out_dir: Path) -> List[Path]:
        if not langs:
            return []
        # Try languages sequentially to know which file corresponds to which language
        created_all: List[Path] = []
        loop = asyncio.get_event_loop()
        for lang in langs:
            opts = self._ytdlp_base_opts() | {
                "skip_download": True,
                "writesubtitles": True,
                "writeautomaticsub": include_auto,
                "subtitleslangs": [lang],
                # Let yt-dlp output vtt or srt; we parse both
                # "convertsubtitles": "srt",
                "outtmpl": str(out_dir / "%(id)s.%(ext)s"),
            }
            # Do NOT apply aggressive SSL bypass here; it may skip subtitles in extractor args
            before = set(self._list_subtitle_files(out_dir))
            try:
                await loop.run_in_executor(None, lambda: yt_dlp.YoutubeDL(opts).download([url]))
            except Exception as e:
                # Try a targeted fallback with forced web client
                msg = str(e)
                if "not available on this app" in msg.lower() or "requested format is not available" in msg.lower():
                    try:
                        fallback_opts = opts | {
                            "http_headers": {
                                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
                            },
                            "extractor_args": {"youtube": {"player_client": ["web"]}},
                        }
                        await loop.run_in_executor(None, lambda: yt_dlp.YoutubeDL(fallback_opts).download([url]))
                    except Exception:
                        continue
                else:
                    continue
            after = set(self._list_subtitle_files(out_dir))
            created = sorted(list(after - before))
            created_all.extend(created)
            # If we created at least one file for this language, stop early
            if created:
                break
        return created_all

    async def _fetch_manual_captions_ytdlp(
        self,
        video_id: str,
        youtube_url: str,
        languages: List[str],
        source: TranscriptSource,
    ) -> TranscriptResult:
        """Try downloading manually created subtitles using yt-dlp.

        Always prefer the video's original language for manual captions. If manual
        captions in the video's language (including region variants like en-US)
        are not available, do not fall back to other manual languages; allow the
        overall strategy to continue to auto-generated/ASR fallbacks.
        """
        # Try probing for manual subtitles
        manual: Dict[str, Any] = {}
        video_lang: str = ""
        try:
            info = self._ytdlp_probe_info(youtube_url)
            manual = info.get("subtitles") or {}
            video_lang = (info.get("audio_language") or info.get("language") or info.get("original_language") or "").lower()
        except TranscriptTemporaryError:
            manual = {}
            video_lang = ""

        # Build attempt list: only the video's language (including region variants)
        manual_lang_keys = list(manual.keys())
        attempt_langs: List[str] = []
        if video_lang:
            # Exact or regional variants first
            matching_variants = [k for k in manual_lang_keys if k == video_lang or k.startswith(f"{video_lang}-")]
            attempt_langs.extend(matching_variants)
        # If there are no manual captions in the video's language, do not attempt other manual languages
        if not attempt_langs:
            raise TranscriptUnavailableError("Manual subtitles do not include the video's language")

        # Download the advertised manual subtitles, trying languages in order.
        # If we had no language list, try downloading all manual subtitles.
        with tempfile.TemporaryDirectory() as tmpdir:
            out_dir = Path(tmpdir)
            created_files: List[Path] = []
            if attempt_langs:
                created_files = await self._download_captions(
                    url=youtube_url, langs=attempt_langs, include_auto=False, out_dir=out_dir
                )
            if not created_files:
                raise TranscriptUnavailableError("Manual subtitles download yielded no files")

            # Choose the first created file (we attempted languages in order)
            chosen_file: Path = created_files[0]
            # Best-effort language detection
            chosen_lang = None
            # Try to infer from filename or based on attempted order
            inferred = self._infer_lang_from_filename(video_id, chosen_file)
            if inferred:
                chosen_lang = inferred
            elif attempt_langs:
                chosen_lang = attempt_langs[0]

            segments = self._parse_subtitle_file(chosen_file)
            if not segments:
                raise TranscriptUnavailableError("Parsed manual subtitles were empty")
            transcript_text = " ".join(seg["text"] for seg in segments)
            return TranscriptResult(
                success=True,
                transcript=transcript_text,
                segments=segments,
                source=TranscriptSource.MANUAL_CAPTIONS,
                language=chosen_lang or self._detect_transcript_language(transcript_text),
            )

    async def _fetch_auto_captions_ytdlp(
        self,
        video_id: str,
        youtube_url: str,
        languages: List[str],
        source: TranscriptSource,
    ) -> TranscriptResult:
        """Try auto-generated subtitles across languages via yt-dlp.

        - Prefer preferred languages; else try video language; else any available (limited count)
        - If probe fails, try common variants
        """
        video_lang = ""
        auto: Dict[str, Any] = {}
        try:
            info = self._ytdlp_probe_info(youtube_url)
            video_lang = (info.get("audio_language") or info.get("language") or info.get("original_language") or "").lower()
            auto = info.get("automatic_captions") or {}
        except TranscriptTemporaryError:
            video_lang = ""
            auto = {}

        preferred_langs = list(dict.fromkeys(languages or ["en"]))
        available_auto_langs = list(auto.keys()) if auto else []

        attempt_langs: List[str] = []
        # Prioritize the video's language first if it exists among auto captions
        if video_lang and video_lang in available_auto_langs:
            attempt_langs.append(video_lang)
        # Then preferred languages present in available auto
        for lang in preferred_langs:
            if lang in available_auto_langs and lang not in attempt_langs:
                attempt_langs.append(lang)
        for lang in available_auto_langs:
            if lang not in attempt_langs:
                attempt_langs.append(lang)
            if len(attempt_langs) >= 5:
                break
        if not attempt_langs:
            # Blind attempts if we couldn't list
            attempt_langs = [l for l in [video_lang, "en", "en-US"] if l]

        with tempfile.TemporaryDirectory() as tmpdir:
            out_dir = Path(tmpdir)
            created_files = await self._download_captions(
                url=youtube_url, langs=attempt_langs, include_auto=True, out_dir=out_dir
            )
            if not created_files:
                raise TranscriptUnavailableError("Auto-generated subtitles download yielded no files")

            chosen_file: Path = created_files[0]
            chosen_lang = self._infer_lang_from_filename(video_id, chosen_file) or attempt_langs[0]

            segments = self._parse_subtitle_file(chosen_file)
            if not segments:
                raise TranscriptUnavailableError("Parsed auto-generated subtitles were empty")
            transcript_text = " ".join(seg["text"] for seg in segments)
            # Clean ONLY for auto-generated captions
            transcript_text = _clean_autogenerated_transcript(transcript_text)
            return TranscriptResult(
                success=True,
                transcript=transcript_text,
                segments=segments,
                source=TranscriptSource.AUTO_GENERATED,
                language=chosen_lang or self._detect_transcript_language(transcript_text),
            )

    async def _fetch_youtube_transcript(
        self, 
        video_id: str, 
        youtube_url: str, 
        languages: List[str],
        source: TranscriptSource
    ) -> TranscriptResult:
        """Fetch transcript using YouTube Transcript API with manual/auto preference and translation fallback."""
        try:
            # Build preferred target language from strategy (first language)
            lang_groups = self._group_languages(languages)
            preferred_targets = lang_groups[0] if lang_groups else ['en']
            preferred_target = preferred_targets[0] if preferred_targets else 'en'

            # First try the simple direct fetch path (works on newer API)
            try:
                api = self._get_ytt_api()
                direct_languages = preferred_targets or ['en']
                if hasattr(api, 'fetch'):
                    fetched = api.fetch(
                        video_id,
                        languages=['de','en','es','fr','it','pt','ru','ja','ko','zh','hi','ar','ta']
                    )  # type: ignore[call-arg]
                    entries = self._normalize_transcript_entries(fetched)
                    if entries:
                        transcript_text = ' '.join([seg['text'] for seg in entries])
                        detected_lang = self._detect_transcript_language(transcript_text)
                        return TranscriptResult(
                            success=True,
                            transcript=transcript_text,
                            segments=entries,
                            source=source,
                            language=detected_lang or (direct_languages[0] if direct_languages else 'en'),
                        )
            except TranscriptRateLimitError:
                raise
            except Exception:
                # Fall through to list-based strategy
                pass

            # List available transcripts for the video (prefer instance API, fall back to legacy static)
            transcript_tracks = None
            try:
                api = self._get_ytt_api()
                if hasattr(api, 'list'):
                    transcript_tracks = api.list(video_id)  # type: ignore[call-arg]
                elif hasattr(YouTubeTranscriptApi, 'list_transcripts'):
                    # Legacy static method (<=0.6.x)
                    transcript_tracks = YouTubeTranscriptApi.list_transcripts(video_id)  # type: ignore[attr-defined]
                else:
                    transcript_tracks = None
            except Exception:
                transcript_tracks = None

            # Helper to pick the best matching track
            def select_track() -> Optional[Any]:
                # 1) Try manually created transcripts in preferred languages
                if self.language_prefs.prefer_manual_captions:
                    for lang in preferred_targets:
                        try:
                            return transcript_tracks.find_manually_created_transcript([lang])
                        except Exception:
                            continue
                # 2) Try any manual transcript if not found in preferred languages
                if self.language_prefs.prefer_manual_captions:
                    for t in transcript_tracks:
                        try:
                            if not getattr(t, 'is_generated', False):
                                return t
                        except Exception:
                            continue
                # 3) Try auto-generated in preferred languages
                for lang in preferred_targets:
                    try:
                        return transcript_tracks.find_generated_transcript([lang])
                    except Exception:
                        continue
                # 4) Fall back to any available transcript
                for t in transcript_tracks:
                    return t
                return None

            selected = select_track() if transcript_tracks is not None else None
            if not selected:
                # Fallback: if we cannot get a TranscriptList, try direct fetch using language preferences (new API)
                try:
                    api = self._get_ytt_api()
                    # Determine languages list for direct fetch
                    languages_for_fetch = languages or ['en']
                    if hasattr(api, 'fetch'):
                        fetched = api.fetch(video_id, languages=languages_for_fetch)  # type: ignore[call-arg]
                        # Normalize fetched transcript
                        try:
                            raw_entries = getattr(fetched, 'to_raw_data', lambda: list(fetched))()
                        except Exception:
                            raw_entries = list(fetched)
                        transcript_entries = raw_entries
                        if not transcript_entries:
                            raise TranscriptUnavailableError("Empty transcript returned by YouTube")
                        # Build segments
                        segments = []
                        for item in transcript_entries:
                            try:
                                text = item.get('text', '').strip()
                                start = float(item.get('start', 0))
                                duration = float(item.get('duration', 0)) if 'duration' in item else 0.0
                                if text:
                                    segments.append({'text': text, 'start': start, 'duration': duration})
                            except Exception:
                                continue
                        if not segments:
                            raise TranscriptUnavailableError("No usable segments in transcript")
                        transcript_text = ' '.join([seg['text'] for seg in segments])
                        detected_lang = self._detect_transcript_language(transcript_text)
                        return TranscriptResult(
                            success=True,
                            transcript=transcript_text,
                            segments=segments,
                            source=source,
                            language=detected_lang or (languages[0] if languages else 'en'),
                        )
                except (TranscriptUnavailableError, TranscriptRateLimitError):
                    raise
                except Exception:
                    pass
                raise TranscriptUnavailableError("No transcript tracks available")

            # If selected language differs and translation is supported, translate to preferred target
            try:
                selected_lang = getattr(selected, 'language_code', None)
                if preferred_target and selected_lang and selected_lang != preferred_target and getattr(selected, 'is_translatable', False):
                    selected = selected.translate(preferred_target)
                    selected_lang = preferred_target
            except Exception:
                # Continue with original language if translation fails
                pass

            # Fetch the transcript entries
            try:
                transcript_entries = selected.fetch()
            except TooManyRequests as e:
                raise TranscriptRateLimitError(f"Rate limit exceeded: {e}")
            except (NoTranscriptFound, NoTranscriptAvailable, TranscriptsDisabled, VideoUnavailable, CouldNotRetrieveTranscript) as e:
                raise TranscriptUnavailableError(f"No transcript available: {e}")
            except Exception as e:
                # Intermittent or network errors
                error_msg = str(e).lower()
                if 'certificate verify failed' in error_msg or 'ssl' in error_msg:
                    raise TranscriptTemporaryError(f"SSL certificate error: {e}")
                raise TranscriptTemporaryError(f"YouTube transcript fetch error: {e}")

            # Normalize entries to list of dicts
            transcript_entries = self._normalize_transcript_entries(transcript_entries)

            if not transcript_entries:
                raise TranscriptUnavailableError("Empty transcript returned by YouTube")

            # Normalize and format
            segments = transcript_entries

            if not segments:
                raise TranscriptUnavailableError("No usable segments in transcript")

            transcript_text = ' '.join([seg['text'] for seg in segments])
            detected_lang = self._detect_transcript_language(transcript_text)

            return TranscriptResult(
                success=True,
                transcript=transcript_text,
                segments=segments,
                source=source,
                language=detected_lang or getattr(selected, 'language_code', None) or preferred_target,
            )

        except (TranscriptUnavailableError, TranscriptRateLimitError):
            raise
        except Exception as e:
            # Treat unknown errors as temporary to allow retry/backoff
            raise TranscriptTemporaryError(f"YouTube API error: {e}")
    
    async def _fetch_whisper_transcript_openai(
        self, 
        video_id: str, 
        youtube_url: str, 
        languages: List[str],
        source: TranscriptSource
    ) -> TranscriptResult:
        """Fetch transcript using OpenAI Whisper."""
        try:
            primary_lang = languages[0] if languages else 'en'
            transcript_obj = await self.whisper_openai.get(
                video_id=video_id, 
                language=primary_lang
            )
            
            if transcript_obj and transcript_obj.segments:
                segments = [
                    {
                        "text": seg.text,
                        "start": seg.start,
                        "duration": seg.duration or 0
                    }
                    for seg in transcript_obj.segments
                ]
                
                return TranscriptResult(
                    success=True,
                    transcript=transcript_obj.text,
                    segments=segments,
                    source=source,
                    language=primary_lang
                )
            else:
                raise TranscriptUnavailableError("Whisper OpenAI returned empty transcript")
                
        except TranscriptUnavailable as e:
            raise TranscriptUnavailableError(f"Whisper OpenAI unavailable: {e}")
        except Exception as e:
            raise TranscriptTemporaryError(f"Whisper OpenAI error: {e}")
    
    async def _fetch_whisper_transcript_groq(
        self, 
        video_id: str, 
        youtube_url: str, 
        languages: List[str],
        source: TranscriptSource
    ) -> TranscriptResult:
        """Fetch transcript using Groq Whisper."""
        try:
            primary_lang = languages[0] if languages else 'en'
            transcript_obj = await self.whisper_groq.get(
                video_id=video_id, 
                language=primary_lang
            )
            
            if transcript_obj and transcript_obj.segments:
                segments = [
                    {
                        "text": seg.text,
                        "start": seg.start,
                        "duration": seg.duration or 0
                    }
                    for seg in transcript_obj.segments
                ]
                
                return TranscriptResult(
                    success=True,
                    transcript=transcript_obj.text,
                    segments=segments,
                    source=source,
                    language=primary_lang
                )
            else:
                raise TranscriptUnavailableError("Whisper Groq returned empty transcript")
                
        except TranscriptUnavailable as e:
            raise TranscriptUnavailableError(f"Whisper Groq unavailable: {e}")
        except Exception as e:
            raise TranscriptTemporaryError(f"Whisper Groq error: {e}")
    
    async def _execute_with_retry(
        self, 
        fetch_func, 
        video_id: str, 
        youtube_url: str, 
        languages: List[str],
        source: TranscriptSource
    ) -> TranscriptResult:
        """Execute fetch function with retry logic and exponential backoff."""
        last_exception = None
        
        for attempt in range(self.max_retries + 1):
            try:
                result = await fetch_func(video_id, youtube_url, languages, source)
                
                if attempt > 0:
                    logger.info(f"Succeeded on attempt {attempt + 1} for {video_id} using {source.value}")
                
                return result
                
            except TranscriptUnavailableError as e:
                # Don't retry for unavailable transcripts
                return TranscriptResult(
                    success=False,
                    error=str(e),
                    source=source,
                    attempt_count=attempt + 1
                )
                
            except TranscriptRateLimitError as e:
                # Rate limit - wait longer before retry
                if attempt < self.max_retries:
                    delay = min(self.base_retry_delay * (3 ** attempt), self.max_retry_delay)
                    logger.warning(f"Rate limit for {source.value}, waiting {delay}s before retry {attempt + 1}")
                    await asyncio.sleep(delay)
                    last_exception = e
                else:
                    return TranscriptResult(
                        success=False,
                        error=str(e),
                        source=source,
                        attempt_count=attempt + 1
                    )
                    
            except TranscriptTemporaryError as e:
                # Temporary error - retry with exponential backoff
                if attempt < self.max_retries:
                    delay = min(self.base_retry_delay * (2 ** attempt) + random.uniform(0, 1), self.max_retry_delay)
                    logger.warning(f"Temporary error for {source.value}, waiting {delay:.2f}s before retry {attempt + 1}: {e}")
                    await asyncio.sleep(delay)
                    last_exception = e
                else:
                    return TranscriptResult(
                        success=False,
                        error=str(e),
                        source=source,
                        attempt_count=attempt + 1
                    )
                    
            except Exception as e:
                # Unexpected error - treat as temporary
                if attempt < self.max_retries:
                    delay = min(self.base_retry_delay * (2 ** attempt), self.max_retry_delay)
                    logger.error(f"Unexpected error for {source.value}, waiting {delay:.2f}s before retry {attempt + 1}: {e}")
                    await asyncio.sleep(delay)
                    last_exception = e
                else:
                    return TranscriptResult(
                        success=False,
                        error=f"Unexpected error: {e}",
                        source=source,
                        attempt_count=attempt + 1
                    )
        
        # All retries exhausted
        return TranscriptResult(
            success=False,
            error=f"Max retries exceeded. Last error: {last_exception}",
            source=source,
            attempt_count=self.max_retries + 1
        )
    
    def _build_language_strategy(self, preferred_language: Optional[str]) -> List[str]:
        """Build intelligent language priority list."""
        languages = []
        
        # Add preferred language first
        if preferred_language:
            languages.append(preferred_language)
        
        # Add primary languages
        for lang in self.language_prefs.primary_languages:
            if lang not in languages:
                languages.append(lang)
        
        # Add secondary languages
        for lang in self.language_prefs.secondary_languages:
            if lang not in languages:
                languages.append(lang)
        
        return languages
    
    def _group_languages(self, languages: List[str]) -> List[List[str]]:
        """Group languages for progressive fallback strategy."""
        if not languages:
            return [['en']]
        
        groups = []
        
        # Group 1: Primary languages (first 3)
        primary = languages[:3]
        if primary:
            groups.append(primary)
        
        # Group 2: Extended set (first 7)
        if len(languages) > 3:
            extended = languages[:7]
            groups.append(extended)
        
        # Group 3: All languages
        if len(languages) > 7:
            groups.append(languages)
        
        return groups
    
    def _detect_transcript_language(self, text: str) -> Optional[str]:
        """Detect language of transcript text (basic implementation)."""
        if not text or len(text.strip()) < 50:
            return None
        
        # Basic language detection based on common words/patterns
        text_lower = text.lower()
        
        # English patterns
        if any(word in text_lower for word in ['the', 'and', 'you', 'that', 'this', 'with', 'for']):
            return 'en'
        
        # German patterns
        if any(word in text_lower for word in ['der', 'die', 'das', 'und', 'ist', 'mit', 'fÃ¼r']):
            return 'de'
        
        # Spanish patterns
        if any(word in text_lower for word in ['el', 'la', 'y', 'que', 'de', 'con', 'para']):
            return 'es'
        
        # French patterns
        if any(word in text_lower for word in ['le', 'la', 'et', 'que', 'de', 'avec', 'pour']):
            return 'fr'
        
        return None
    
    def _is_source_available(self, source: TranscriptSource) -> bool:
        """Check if source is available based on circuit breaker state."""
        if not self.enable_circuit_breaker:
            return True
        
        breaker = self.circuit_breakers[source]
        current_time = time.time()
        
        if breaker.state == "open":
            # Check if we can transition to half-open
            if current_time - breaker.last_failure_time > breaker.recovery_timeout:
                breaker.state = "half_open"
                logger.info(f"Circuit breaker for {source.value} transitioning to half-open")
                return True
            return False
        
        return True  # closed or half_open
    
    def _record_failure(self, source: TranscriptSource):
        """Record failure for circuit breaker."""
        if not self.enable_circuit_breaker:
            return
        
        breaker = self.circuit_breakers[source]
        breaker.failures += 1
        breaker.last_failure_time = time.time()
        
        if breaker.failures >= breaker.failure_threshold:
            breaker.state = "open"
            logger.warning(f"Circuit breaker for {source.value} opened after {breaker.failures} failures")
    
    def _record_success(self, source: TranscriptSource):
        """Record success for circuit breaker."""
        if not self.enable_circuit_breaker:
            return
        
        breaker = self.circuit_breakers[source]
        breaker.failures = 0
        breaker.state = "closed"
    
    def _update_success_metrics(self, source: TranscriptSource, response_time_ms: int):
        """Update success metrics."""
        self._record_success(source)
        # Update metrics here (simplified)
    
    def _update_failure_metrics(self):
        """Update failure metrics."""
        # Update metrics here (simplified)
        pass
    
    async def _get_cached_transcript(self, video_id: str) -> Optional[TranscriptResult]:
        """Get cached transcript result."""
        cache_key = f"robust_transcript_{video_id}"
        cached = self.cache.get("transcripts", cache_key)
        
        if cached:
            return TranscriptResult(
                success=True,
                transcript=cached.get("transcript"),
                segments=cached.get("segments"),
                source=TranscriptSource(cached.get("source", "youtube_api")),
                language=cached.get("language")
            )
        
        return None
    
    async def _cache_transcript_result(self, video_id: str, result: TranscriptResult):
        """Cache successful transcript result."""
        if result.success:
            cache_key = f"robust_transcript_{video_id}"
            cache_data = {
                "transcript": result.transcript,
                "segments": result.segments,
                "source": result.source.value if result.source else None,
                "language": result.language,
                "cached_at": time.time()
            }
            self.cache.set("transcripts", cache_key, cache_data)
    
    def get_metrics(self) -> Dict[str, Any]:
        """Get performance metrics."""
        return self.metrics.copy()
    
    def reset_circuit_breakers(self):
        """Reset all circuit breakers (for testing/admin purposes)."""
        for breaker in self.circuit_breakers.values():
            breaker.failures = 0
            breaker.state = "closed"
            breaker.last_failure_time = 0
        logger.info("All circuit breakers reset") 